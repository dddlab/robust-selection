mf <- model.frame(Terms, newdata, na.action = na.pass, xlev = multi.lm$xlevels)
z0 <- model.matrix(Terms, mf, contrasts.arg = multi.lm$contrasts)
rad <- sqrt((m*(n-r-1)/(n-r-m))*qf(0.95,m,n-r-m)*(1 + z0%*%solve(t(Z)%*%Z) %*% t(z0)))
# generate ellipse using ellipse function in car package
ell_points <- car::ellipse(center = c(cent), shape = S, radius = c(rad), draw = FALSE)
plot(ell_points, type = "l", xlab = resps[1], ylab = resps[2],  main="95% Prediction Ellipse for TOT and AMI")
points(x = cent[1], y = cent[2])
z0
newdata <- matrix(1,GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85))
newdata <- matrix(1,data.frame(GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85)))
x0 <- cbind(1,newdata)
x0
total.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + x0%*%solve(t(X)%*%X) %*% t(x0))
x0 <- matrix(cbind(1,newdata),nrow=1)
x0
total.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + x0%*%solve(t(X)%*%X) %*% t(x0))
solve(t(X)%*%X)
x0 %*% solve(t(X)%*%X)
x0
as.matrix(solve(t(X)%*%X))
x0 %*% as.matrix(solve(t(X)%*%X))
x0 %*% matrix(solve(t(X)%*%X))
x0 %*% (solve(t(X)%*%X))
matrix(x0) %*% (solve(t(X)%*%X))
(solve(t(X)%*%X))
X
mf
mf
model.frame(Terms, newdata, na.action = na.pass, xlev = multi.lm$xlevels)
sigma.hat.1 <- sqrt(sum(total.lm$residuals^2)/total.lm$df.residual)
X <- model.matrix(total.lm)
newdata <- data.frame(GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85))
total.newpred <- predict(total.lm , newdata=newdata, se=T, interval="prediction", level=0.95)
tt <- terms(total.lm)
Terms <- delete.response(total.lm)
mf <- model.frame(Terms, newdata, na.action = na.pass, xlev = multi.lm$xlevels)
z0 <- model.matrix(Terms, mf, contrasts.arg = multi.lm$contrasts)
total.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + z0 %*% solve(t(X)%*%X) %*% t(z0))
X <- model.matrix(total.lm)
newdata <- data.frame(GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85))
#newdata <- data.frame(GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85))
newdata <- matrix(1,1,1200,140,70,85)
#newdata <- data.frame(GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85))
newdata <- matrix(c(GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85)), ncol=6)
newdata
#newdata <- data.frame(GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85))
newdata <- matrix(c(1, GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85)), ncol=6)
newdata
total.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + newdata %*% solve(t(X)%*%X) %*% t(newdata))
+
total.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + newdata %*% solve(t(X)%*%X) %*% t(newdata))
X
c("Fitted" = total.newpred$fit[,1],
c("Fitted" = total.newpred$fit[,1],
"Lower" = total.newpred$fit[,1]-sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + newdata %*% solve(t(X)%*%X) %*% t(newdata)),
"Upper" = total.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + newdata %*% solve(t(X)%*%X) %*% t(newdata)))
)
c("Fitted" = total.newpred$fit[,1],
"Lower" = total.newpred$fit[,1]-sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + newdata %*% solve(t(X)%*%X) %*% t(newdata)),
"Upper" = total.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + newdata %*% solve(t(X)%*%X) %*% t(newdata))))
c("Fitted" = total.newpred$fit[,1],
"Lower" = total.newpred$fit[,1]-sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + newdata %*% solve(t(X)%*%X) %*% t(newdata)),
"Upper" = total.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + newdata %*% solve(t(X)%*%X) %*% t(newdata)))
c("Fitted" = total.newpred$fit[,1],
"Lower" = total.newpred$fit[,1]-sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + newdata %*% solve(t(X)%*%X) %*% t(newdata)),
"Upper" = total.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + newdata %*% solve(t(X)%*%X) %*% t(newdata)))
ami.lm <- lm(AMI ~ GEN + AMT + PR + DIAP + QRS, data=data)
par(mfrow=c(2,2))
plot(ami.lm,c(1,2,4,5))
ncvTest(ami.lm )
shapiro.test(ami.lm $residuals)
outlierTest(ami.lm)
sigma.hat.2 <- sqrt(sum(ami.lm$residuals^2)/ami.lm$df.residual)
sigma.hat.2 <- sqrt(sum(ami.lm$residuals^2)/ami.lm$df.residual)
ami.newpred <- predict(ami.lm , newdata=newdata, se=T, interval="prediction", level=0.95)
sigma.hat.1 <- sqrt(sum(total.lm$residuals^2)/total.lm$df.residual)
X <- model.matrix(total.lm)
newdata <- matrix(c(1, GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85)), ncol=6)
total.newpred <- predict(total.lm , newdata=newdata, se=T, interval="prediction", level=0.95)
data.frame(newdata)
newdata <- data.frame(GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85))
x0 <- matrix(c(1, GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85)), ncol=6)
total.newpred <- predict(total.lm , newdata=newdata, se=T, interval="prediction", level=0.95)
c("Fitted" = total.newpred$fit[,1],
"Lower" = total.newpred$fit[,1]-sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + newdata %*% solve(t(X)%*%X) %*% t(newdata)),
"Upper" = total.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + newdata %*% solve(t(X)%*%X) %*% t(newdata)))
c("Fitted" = total.newpred$fit[,1],
"Lower" = total.newpred$fit[,1]-sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + x0 %*% solve(t(X)%*%X) %*% t(x0)),
"Upper" = total.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + x0 %*% solve(t(X)%*%X) %*% t(x0)))
sigma.hat.1 <- sqrt(sum(total.lm$residuals^2)/total.lm$df.residual)
X <- model.matrix(total.lm)
newdata <- data.frame(GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85))
x0 <- matrix(c(1, GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85)), ncol=6)
total.newpred <- predict(total.lm , newdata=newdata, se=T, interval="prediction", level=0.95)
c("Fitted" = total.newpred$fit[,1],
"Lower" = total.newpred$fit[,1]-sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + x0 %*% solve(t(X)%*%X) %*% t(x0)),
"Upper" = total.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1 + x0 %*% solve(t(X)%*%X) %*% t(x0)))
sigma.hat.2 <- sqrt(sum(ami.lm$residuals^2)/ami.lm$df.residual)
ami.newpred <- predict(ami.lm , newdata=newdata, se=T, interval="prediction", level=0.95)
c("Fitted" = ami.newpred$fit[,1],
"Lower" = ami.newpred$fit[,1]-sqrt(6*qf(.95,6,17-6))*sigma.hat.2*sqrt(1 + newdata %*% solve(t(X)%*%X) %*% t(newdata)),
"Upper" = ami.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.2*sqrt(1 + newdata %*% solve(t(X)%*%X) %*% t(newdata)))
c("Fitted" = ami.newpred$fit[,1],
"Lower" = ami.newpred$fit[,1]-sqrt(6*qf(.95,6,17-6))*sigma.hat.2*sqrt(1 + x0 %*% solve(t(X)%*%X) %*% t(x0)),
"Upper" = ami.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.2*sqrt(1 + x0 %*% solve(t(X)%*%X) %*% t(x0)))
multi.lm <- lm(cbind(TOT, AMI) ~ GEN + AMT + PR + DIAP + QRS, data=data)
resps <- colnames(multi.lm$coefficients)
p <- predict(multi.lm, newdata)
# center of ellipse
cent <- c(p[1,1],p[1,2])
# shape of ellipse
Z <- model.matrix(multi.lm)
Y <- multi.lm$model[[1]]
n <- nrow(Y)
m <- ncol(Y)
r <- ncol(Z) - 1
S <- crossprod(resid(multi.lm))/(n-r-1)
# radius of circle generating the ellipse
tt <- terms(multi.lm)
Terms <- delete.response(tt)
mf <- model.frame(Terms, newdata, na.action = na.pass, xlev = multi.lm$xlevels)
z0 <- model.matrix(Terms, mf, contrasts.arg = multi.lm$contrasts)
rad <- sqrt((m*(n-r-1)/(n-r-m))*qf(0.95,m,n-r-m)*(1 + z0%*%solve(t(Z)%*%Z) %*% t(z0)))
# generate ellipse using ellipse function in car package
ell_points <- car::ellipse(center = c(cent), shape = S, radius = c(rad), draw = FALSE)
plot(ell_points, type = "l", xlab = resps[1], ylab = resps[2],  main="95% Prediction Ellipse for TOT and AMI")
points(x = cent[1], y = cent[2])
library(knitr)
library(tidyverse)
library(Matrix)
library(DiceKriging)
library(RobustGaSP)
library(lhs)
library(car)
knitr::opts_chunk$set(echo=TRUE,
cache=FALSE,
fig.width=5,
fig.height=5,
fig.align='center')
indent1 = '    '
indent2 = paste(rep(indent1, 2), collapse='')
indent3 = paste(rep(indent1, 3), collapse='')
data <- data.frame(TOT = c(3389,1101,1131,596,896,1767,807,1111,645,628,1360,652,860,500,781,1070,1754),
AMI = c(3149,653,810,448,844,1450,493,941,547,392,1283,458,722,384,501,405,1520),
GEN = c(1,1,0,1,1,1,1,0,1,1,1,1,1,0,0,0,1),
AMT = c(7500,1975,3600,675,750,2500,350,1500,375,1050,3000,450,1750,2000,4500,1500,3000),
PR = c(220,200,205,160,185,180,154,200,137,167,180,160,135,160,180,170,180),
DIAP = c(0,0,60,60,70,60,80,70,60,60,60,64,90,60,0,90,0),
QRS = c(140,100,111,120,83,80,98,93,105,74,80,60,79,80,100,120,129))
total.lm <- lm(TOT ~ GEN + AMT + PR + DIAP + QRS, data=data)
par(mfrow=c(2,2))
plot(total.lm,c(1,2,4,5))
ncvTest(total.lm )
shapiro.test(total.lm $residuals)
outlierTest(total.lm)
sigma.hat.1 <- sqrt(sum(total.lm$residuals^2)/total.lm$df.residual)
X <- model.matrix(total.lm)
newdata <- data.frame(GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85))
x0 <- matrix(c(1, GEN = c(1), AMT = c(1200), PR = c(140), DIAP = c(70), QRS = c(85)), ncol=6)
total.newpred <- predict(total.lm , newdata=newdata, se=T, interval="prediction", level=0.95)
c("Fitted"=total.newpred$fit[,1],
"Lower"=total.newpred$fit[,1]-sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1+x0 %*%solve(t(X)%*%X)%*%t(x0)),
"Upper"=total.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.1*sqrt(1+x0 %*%solve(t(X)%*%X)%*%t(x0)))
ami.lm <- lm(AMI ~ GEN + AMT + PR + DIAP + QRS, data=data)
par(mfrow=c(2,2))
plot(ami.lm,c(1,2,4,5))
ncvTest(ami.lm )
shapiro.test(ami.lm $residuals)
outlierTest(ami.lm)
sigma.hat.2 <- sqrt(sum(ami.lm$residuals^2)/ami.lm$df.residual)
ami.newpred <- predict(ami.lm , newdata=newdata, se=T, interval="prediction", level=0.95)
c("Fitted"=ami.newpred$fit[,1],
"Lower"=ami.newpred$fit[,1]-sqrt(6*qf(.95,6,17-6))*sigma.hat.2*sqrt(1+x0%*%solve(t(X)%*%X)%*%t(x0)),
"Upper"=ami.newpred$fit[,1]+sqrt(6*qf(.95,6,17-6))*sigma.hat.2*sqrt(1+x0%*%solve(t(X)%*%X)%*%t(x0)))
multi.lm <- lm(cbind(TOT, AMI) ~ GEN + AMT + PR + DIAP + QRS, data=data)
resps <- colnames(multi.lm$coefficients)
p <- predict(multi.lm, newdata)
# center of ellipse
cent <- c(p[1,1],p[1,2])
# shape of ellipse
Z <- model.matrix(multi.lm)
Y <- multi.lm$model[[1]]
n <- nrow(Y)
m <- ncol(Y)
r <- ncol(Z) - 1
S <- crossprod(resid(multi.lm))/(n-r-1)
# radius of circle generating the ellipse
tt <- terms(multi.lm)
Terms <- delete.response(tt)
mf <- model.frame(Terms, newdata, na.action = na.pass, xlev = multi.lm$xlevels)
z0 <- model.matrix(Terms, mf, contrasts.arg = multi.lm$contrasts)
rad <- sqrt((m*(n-r-1)/(n-r-m))*qf(0.95,m,n-r-m)*(1 + z0%*%solve(t(Z)%*%Z) %*% t(z0)))
# generate ellipse using ellipse function in car package
ell_points <- car::ellipse(center = c(cent), shape = S, radius = c(rad), draw = FALSE)
plot(ell_points, type = "l", xlab = resps[1], ylab = resps[2],  main="95% Prediction Ellipse for TOT and AMI")
points(x = cent[1], y = cent[2])
pi-2
sqrt(2)
load("~/research-code/gene-network/gene-net.RData")
5950 - 5667
list(c(1:10))
to_list
tolist
as.list
as.list(1:10)
length(as.list(1:10))
?apply
?lappy
?lapply
library(glasso)
?glasso
s=c(10,1,5,4,10,2,6,10,3,10)
S=matrix(0,nrow=4,ncol=4)
S[row(S)>=col(S)]=s
S=(S+t(S))
diag(S)<-10
zero<-matrix(c(1,3,2,4),ncol=2,byrow=TRUE)
lapply(as.list(1:3), glasso, S=S)
lapply(as.list(1:3), glasso, S=S)
S
lapply(rho=as.list(1:3), glasso, S=S)
lapply(as.list(1:3), FUN=glasso, S=S)
S
?glasso
lapply(as.list(1:3), FUN=glasso, s=S)
library(MASS)
mvtnorm
mvrnorm()
mvrnorm
library(mvtnorm)
mvtnorm::dmvnorm()
rmvnorm()
rmvnorm
append(list(1), list(2))
library(glasso)
?glasso
s=c(10,1,5,4,10,2,6,10,3,10)
S=matrix(0,nrow=4,ncol=4)
S[row(S)>=col(S)]=s
S=(S+t(S))
diag(S)<-10
zero<-matrix(c(1,3,2,4),ncol=2,byrow=TRUE)
a<-glasso(S,0,zero=zero)
s=c(10,1,5,4,10,2,6,10,3,10)
S=matrix(0,nrow=4,ncol=4)
S[row(S)>=col(S)]=s
S=(S+t(S))
diag(S)<-10
zero<-matrix(c(1,3,2,4),ncol=2,byrow=TRUE)
a<-glasso(S,0,zero=zero)
a
append(a,a)
b <- append(a,a)
b$loglik
b
b$niter
a
as.list(a)
list(a)
append(list(a), list(a))
b <- append(list(a), list(a))
b
b[[1]]
b[[2]]
a$lambda <- 10
a
b$lambda <- c(10,20)
b
b <- append(list(a), list(a))
b
b <- append(list(c(a, alpha=0.1)), list(a))
b
b
b
a
b <- append(list(a), list(a))
b
lapply(b, c(a, alpha=0.1))
lapply(b, c(b, alpha=0.1))
lapply(b, c(alpha=0.1))
lapply(b, c
)
lapply(b, c, 0.1)
lapply(b, c, alpha=0.1)
lapply(b, c, alpha=(0.1,0.2))
lapply(b, c, alpha=c(0.1,0.2))
lapply(b, c, alpha=c(0.1,0.2))
mapply(append, b, alpha=c(0.1,0.2), SIMPLIFY = FALSE)
mapply(append, b, alpha=0.1, SIMPLIFY = FALSE)
mapply(append, b, SIMPLIFY = FALSE)
mapply(append, b, values=0.1, SIMPLIFY = FALSE)
mapply(append, b, values=list(0.1,0.2), SIMPLIFY = FALSE)
mapply(append, b, values=list(alpha=c(0.1,0.2)), SIMPLIFY = FALSE)
mapply(append, b, values=list(alpha=(0.1,0.2)), SIMPLIFY = FALSE)
mapply(append, b, values=list(alpha=c(0.1,0.2)), SIMPLIFY = FALSE)
mapply(append, b, values=list(alpha=0.1), SIMPLIFY = FALSE)
b
mapply(append, b, values=list(alpha=0.1), SIMPLIFY = FALSE)
mapply(append, b, values=alphas, SIMPLIFY = FALSE)
alpha = c(1)
mapply(append, b, values=alphas, SIMPLIFY = FALSE)
mapply(append, b, values=alpha, SIMPLIFY = FALSE)
alpha = list(alpha = c(0.1,0.2))
alpha
alpha = list(alpha = list(0.1,0.2))
alpha
mapply(append, b, values=alpha, SIMPLIFY = FALSE)
alpha
mapply(append, b, values=alpha, SIMPLIFY = FALSE)
library(robsel)
robsel.glasso
glasso
robsel.glasso
?robsel.glasso
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- robsel.glasso(X = X, alpha = 0.05, B = 200)
a
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- robsel.glasso(X = X)
a
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- lappy(list(0.1,0.5,0.9), robsel.glasso, X=matrix(rnorm(50*5),ncol=5), B=200)
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- lapply(list(0.1,0.5,0.9), robsel.glasso, X=matrix(rnorm(50*5),ncol=5), B=200)
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- lapply(c(0.1,0.5,0.9), robsel.glasso, X=matrix(rnorm(50*5),ncol=5), B=200)
lapply
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- lapply(X=c(0.1,0.5,0.9), robsel.glasso, X=matrix(rnorm(50*5),ncol=5), B=200)
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- apply(X=c(0.1,0.5,0.9), robsel.glasso, X=matrix(rnorm(50*5),ncol=5), B=200)
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- apply(c(0.1,0.5,0.9), robsel.glasso, X=matrix(rnorm(50*5),ncol=5), B=200)
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- mapply(c(0.1,0.5,0.9), robsel.glasso, X=matrix(rnorm(50*5),ncol=5), B=200)
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- mapply(c(0.1,0.5,0.9), robsel.glasso, X=matrix(rnorm(50*5),ncol=5), B=200)
maply
mapply
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- mapply(robsel.glasso,c(0.1,0.5,0.9), X=matrix(rnorm(50*5),ncol=5), B=200)
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- mapply(robsel.glasso, alpha=c(0.1,0.5,0.9), X=matrix(rnorm(50*5),ncol=5), B=200)
?mapply
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- apply(robsel.glasso, alpha=c(0.1,0.5,0.9), X=matrix(rnorm(50*5),ncol=5), B=200)
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- mapply(robsel.glasso, values=c(0.1,0.5,0.9), X=matrix(rnorm(50*5),ncol=5), B=200)
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- robsel.glasso(X = matrix(rnorm(50*5),ncol=5), alpha = 0.05, B = 200)
a
X <-matrix(rnorm(50*20),ncol=20)
#Use Graphical Lasso with estimate regularization parameter lambda from RobSel
a <- robsel.glasso(X = matrix(rnorm(50*5),ncol=5), alpha = c(0.1,0.9), B = 200)
lapply(list, function)
lapply
lapply(list, function)
lapply
lapply(list=as.list(c(0.1,0.9)), robsel.glasso, X=X)
X
lapply(list=as.list(c(0.1,0.9)), glasso, X=X)
lapply(list=as.list(c(0.1,0.9)), glasso, S=X)
lapply(list=as.list(c(0.1,0.9)), glasso, S=cov(X))
lapply(list=as.list(c(0.1,0.9)), FUN=glasso, S=cov(X))
sapply
sapply
?sapply
lapply(list=as.list(c(0.1,0.9)), FUN=robsel.glasso,matrix(rnorm(50*20),ncol=20) )
lapply(list=as.list(c(0.1,0.9)), FUN=robsel.glasso, matrix(rnorm(50*20),ncol=20) )
lapply(0.1, FUN=robsel.glasso, matrix(rnorm(50*20),ncol=20) )
lapply(alpha=0.1, FUN=robsel.glasso, matrix(rnorm(50*20),ncol=20) )
lapply(matrix(rnorm(50*20),ncol=20), FUN=robsel.glasso,  )
S <- cov(X)
lapply(list=as.list(c(0.1,0.9)), glasso,S )
lapply(list=as.list(c(0.1,0.9)), glasso, S=S )
lapply(list=as.list(c(0.1,0.9)), glasso, s=S )
lapply(list=as.list(c(0.1,0.9)), FUN=glasso, s=S )
lapply(X=as.list(c(0.1,0.9)), FUN=glasso, s=S )
lapply(X=as.list(c(0.1,0.9)), FUN=glasso, s=S )
b <- lapply(X=as.list(c(0.1,0.9)), FUN=glasso, s=S )
b$a
b
b[[1]]
sapply(b, get, x="loglik")
sapply(b, get, x="niter")
iter <- sapply(b, get, x="niter")
robsel.glasso()
robsel.glasso
robsel.test <- function (X, alpha = 0.9, B = 200, ...)
{
lambda <- robsel(X, alpha, B)
s <- cov(X)
model <- glasso(s = s, rho = lambda, ...)
returns = list(alpha = alpha, lambda = lambda, Omega = model$wi,
Sigma = model$w)
return(returns)
}
robsel.test
robsel.test <- function (data, alpha = 0.9, B = 200, ...)
{
lambda <- robsel(data, alpha, B)
s <- cov(data)
model <- glasso(s = s, rho = lambda, ...)
returns = list(alpha = alpha, lambda = lambda, Omega = model$wi,
Sigma = model$w)
return(returns)
}
robsel.test
lapply(as.list(c(0.1,0.9)), robsel.test, data=X)
as.list(c(0.1,0.9))
as.list(list(0.1,0.9))
as.list(vector(0.1,0.9))
glasso
getwd()
setwd("~/robust-selection")
setwd("~/robust-selection")
library(devtools)
setwd("~/robust-selection")
library(devtools)
check()
check()
1 <= 0
-1 <= 0
0 <= 0
type(10)
typeof(10)
integer(100)
int(10)
as.integer(10.1)
as.integer(10.9)
as.integer(10.5)
c(-1,0,1) < 0
list(-1,0,1) < 0
sum(list(-1,0,1) < 0)
sum(list(-1,0,1) > 0)
sum(list(-1,0,1) > 1)
c(1:10)[list(1)]
c(1:10)[list(1,2)]
c(1:10)
c(1:10)[1]
c(1:10)[2]
c(15:20)[2]
c(15:20)[list(2)]
list(1,2,3)
as.numeric(list(1,2,3))
ind <- c(0,1,0,2,0,3)
ind
ind[ind=0] <- 1
ind
ind[ind==0] <- 1
ind
?glasso
robsel
check()
check()
document()
check()
document()
check()
data <- <-matrix(rnorm(50*20),ncol=20)
data <- matrix(rnorm(50*20),ncol=20)
robsel(data)
robsel(data, alpha = c(-1,0.1,0.9,1.1))
robsel(data, alpha = c(-1,0.1,0.9))
robsel(data, alpha = c(0.1,0.9))
robsel(data, alpha = c(0.1,0.9))
robsel(data, alpha = c(0.1,0.9))
robsel(data, alpha = c(0.1,0.9))
robsel(data, alpha = c(0.1,-0.9))
robsel(data, alpha = c(0,0.1,0.9))
robsel(data, alpha = c(0,0.1,0.9))
robsel(data, alpha = c(0,1,0.9))
robsel(data, alpha = c(0,1,0.9))
robsel(data, alpha = c(0,0.1,0.9))
robsel(data, alpha = c(0,0.1,0.9))
robsel(data, alpha = c(0,0.1,0.9))
robsel(data, alpha = c(0,0.1,0.9))
robsel(data, alpha = c(0,1,0.9))
robsel(data, alpha = c(0,1,0.9))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
list(lambda= robsel(data, alpha = c(0,1,0.9)))
document()
document()
check()
